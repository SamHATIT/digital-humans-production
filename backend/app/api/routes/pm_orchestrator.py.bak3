"""
PM Orchestrator API routes for project definition and execution.
"""
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.responses import StreamingResponse, FileResponse
from sqlalchemy.orm import Session
from typing import List
import asyncio
import logging
import json
from datetime import datetime

from app.database import get_db
from app.models.user import User
from app.models.project import Project, ProjectStatus
from app.models.execution import Execution, ExecutionStatus
from app.schemas.project import Project as ProjectSchema, ProjectCreate, ProjectUpdate
from app.schemas.execution import (
    ExecutionCreate,
    Execution as ExecutionSchema,
    ExecutionStartResponse,
    ExecutionResultResponse,
    ExecutionProgress
)
from app.utils.dependencies import get_current_user
from app.services.pm_orchestrator_service import execute_agents_background
from app.services.file_processor import FileProcessor
from fastapi import File, UploadFile as FastAPIUploadFile
import os


# Special authentication for SSE and file downloads (query parameter)
from fastapi import Query
from typing import Optional

async def get_user_from_token(
    token: Optional[str] = Query(None),
    db: Session = Depends(get_db)
) -> User:
    """Get user from query parameter token (for SSE/downloads)."""
    if not token:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Token required in query parameter"
        )
    
    try:
        from jose import jwt, JWTError
        from app.config import settings
        
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id = payload.get("sub")
        
        if not user_id:
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Invalid token")
        
        user = db.query(User).filter(User.id == int(user_id)).first()
        if not user:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")
        
        return user
    except JWTError:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Invalid token")


router = APIRouter(prefix="/pm-orchestrator", tags=["PM Orchestrator"])


# ==================== PROJECT DEFINITION ROUTES ====================

@router.post("/projects", response_model=ProjectSchema, status_code=status.HTTP_201_CREATED)
async def create_project(
    project_data: ProjectCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Create a new project definition for PM Orchestrator.

    This endpoint allows users to define a Salesforce project with:
    - Project information (name, Salesforce product, organization type)
    - Business requirements (3-7 bullet points)
    - Technical constraints (existing systems, compliance, etc.)
    - Architecture preferences (optional)
    """
    # Log received data for debugging
    logger = logging.getLogger(__name__)
    logger.info(f"Creating project with data: {project_data.model_dump()}")
    
    project = Project(
        user_id=current_user.id,
        name=project_data.name,
        description=project_data.description,
        salesforce_product=project_data.salesforce_product,
        organization_type=project_data.organization_type,
        business_requirements=project_data.business_requirements,
        existing_systems=project_data.existing_systems,
        compliance_requirements=project_data.compliance_requirements,
        expected_users=project_data.expected_users,
        expected_data_volume=project_data.expected_data_volume,
        architecture_preferences=project_data.architecture_preferences,
        architecture_notes=project_data.architecture_notes,
        requirements_text=project_data.requirements_text,
        status=ProjectStatus.READY
    )

    db.add(project)
    db.commit()
    db.refresh(project)

    return project


@router.get("/projects", response_model=List[ProjectSchema])
async def list_projects(
    skip: int = 0,
    limit: int = 50,
    status: ProjectStatus = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Get all projects for the current user.

    Optional filters:
    - status: Filter by project status (draft, ready, active, completed, archived)
    - skip/limit: Pagination
    """
    query = db.query(Project).filter(Project.user_id == current_user.id)

    if status:
        query = query.filter(Project.status == status)

    projects = query.order_by(Project.created_at.desc()).offset(skip).limit(limit).all()

    return projects


@router.get("/dashboard/stats")


@router.post("/extract-requirements")
async def extract_requirements_from_file(
    file: FastAPIUploadFile = File(...),
    current_user: User = Depends(get_current_user)
):
    """
    Extract text content from uploaded file (PDF, DOCX, TXT).
    
    This endpoint processes the uploaded file and returns its text content
    which can be used as business requirements for project creation.
    """
    # Validate file type
    allowed_extensions = ['.pdf', '.docx', '.doc', '.txt']
    file_ext = os.path.splitext(file.filename)[1].lower()
    
    if file_ext not in allowed_extensions:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"File type {file_ext} not supported. Allowed: {', '.join(allowed_extensions)}"
        )
    
    # Extract text
    text_content = await FileProcessor.extract_text_from_file(file)
    
    if not text_content:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Failed to extract text from file"
        )
    
    return {
        "filename": file.filename,
        "content": text_content,
        "character_count": len(text_content),
        "word_count": len(text_content.split())
    }

async def get_dashboard_stats(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Get dashboard statistics for the current user.

    Returns:
    - Total projects count
    - Projects by status (draft, ready, active, completed, archived)
    - Active executions count
    - Completed executions count
    - Recent projects
    """
    from sqlalchemy import func

    # Total projects
    total_projects = db.query(func.count(Project.id)).filter(
        Project.user_id == current_user.id
    ).scalar()

    # Projects by status
    projects_by_status = {}
    for status in ProjectStatus:
        count = db.query(func.count(Project.id)).filter(
            Project.user_id == current_user.id,
            Project.status == status
        ).scalar()
        projects_by_status[status.value] = count

    # Active executions
    active_executions = db.query(func.count(Execution.id)).filter(
        Execution.user_id == current_user.id,
        Execution.status.in_([ExecutionStatus.PENDING, ExecutionStatus.RUNNING])
    ).scalar()

    # Completed executions
    completed_executions = db.query(func.count(Execution.id)).filter(
        Execution.user_id == current_user.id,
        Execution.status == ExecutionStatus.COMPLETED
    ).scalar()

    # Failed executions
    failed_executions = db.query(func.count(Execution.id)).filter(
        Execution.user_id == current_user.id,
        Execution.status == ExecutionStatus.FAILED
    ).scalar()

    # Recent projects (last 5)
    recent_projects = db.query(Project).filter(
        Project.user_id == current_user.id
    ).order_by(Project.created_at.desc()).limit(5).all()

    return {
        "total_projects": total_projects,
        "projects_by_status": projects_by_status,
        "active_executions": active_executions,
        "completed_executions": completed_executions,
        "failed_executions": failed_executions,
        "recent_projects": [
            {
                "id": p.id,
                "name": p.name,
                "status": p.status.value,
                "salesforce_product": p.salesforce_product,
                "created_at": p.created_at.isoformat() if p.created_at else None
            }
            for p in recent_projects
        ]
    }


@router.get("/projects/{project_id}", response_model=ProjectSchema)
async def get_project(
    project_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Get a specific project by ID.
    """
    project = db.query(Project).filter(
        Project.id == project_id,
        Project.user_id == current_user.id
    ).first()

    if not project:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Project not found"
        )

    return project


@router.put("/projects/{project_id}", response_model=ProjectSchema)
async def update_project(
    project_id: int,
    project_data: ProjectUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Update a project definition.
    """
    project = db.query(Project).filter(
        Project.id == project_id,
        Project.user_id == current_user.id
    ).first()

    if not project:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Project not found"
        )

    # Update only provided fields
    update_data = project_data.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(project, field, value)

    project.updated_at = datetime.utcnow()
    db.commit()
    db.refresh(project)

    return project


@router.delete("/projects/{project_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_project(
    project_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Delete a project.
    """
    project = db.query(Project).filter(
        Project.id == project_id,
        Project.user_id == current_user.id
    ).first()

    if not project:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Project not found"
        )

    db.delete(project)
    db.commit()

    return None


# ==================== EXECUTION ROUTES ====================

@router.post("/execute", response_model=ExecutionStartResponse, status_code=status.HTTP_202_ACCEPTED)
async def start_execution(
    execution_data: ExecutionCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Start execution of selected agents for a project.

    This endpoint:
    1. Validates the project exists and belongs to the user
    2. Validates PM agent is selected (required)
    3. Creates an execution record
    4. Starts background task to execute agents
    5. Returns execution_id to track progress

    The PM agent must always be included in selected_agents.
    """
    # Validate project exists
    project = db.query(Project).filter(
        Project.id == execution_data.project_id,
        Project.user_id == current_user.id
    ).first()

    if not project:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Project not found"
        )

    # Validate PM agent is selected
    # TEMPORARILY DISABLED FOR TESTING:     if 'pm' not in execution_data.selected_agents:
    # TEMPORARILY DISABLED FOR TESTING:         raise HTTPException(
    # TEMPORARILY DISABLED FOR TESTING:             status_code=status.HTTP_400_BAD_REQUEST,
    # TEMPORARILY DISABLED FOR TESTING:             detail="Product Manager (PM) agent is required and must be selected"
    # TEMPORARILY DISABLED FOR TESTING:         )
    # TEMPORARILY DISABLED FOR TESTING: 
    # Initialize agent execution status
    agent_execution_status = {
        agent_id: {
            "state": "waiting",
            "progress": 0,
            "message": "Waiting to start..."
        }
        for agent_id in execution_data.selected_agents
    }

    # Create execution record
    execution = Execution(
        project_id=project.id,
        user_id=current_user.id,
        selected_agents=execution_data.selected_agents,
        agent_execution_status=agent_execution_status,
        status=ExecutionStatus.RUNNING,
        started_at=datetime.utcnow()
    )

    db.add(execution)
    db.commit()
    db.refresh(execution)

    # Start background task for execution
    asyncio.create_task(execute_agents_background(execution.id, project.id, execution_data.selected_agents))

    return ExecutionStartResponse(
        execution_id=execution.id,
        status="started",
        message="Execution started successfully. Use the progress endpoint to track status."
    )


@router.get("/execute/{execution_id}/progress")
async def get_execution_progress(
    execution_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_user_from_token)
):
    """
    Get real-time progress of an execution using Server-Sent Events (SSE).

    This endpoint streams progress updates every 2 seconds until execution completes or fails.

    Frontend usage:
    ```javascript
    const eventSource = new EventSource('/api/pm-orchestrator/execute/123/progress');
    eventSource.onmessage = (event) => {
        const data = JSON.parse(event.data);
        // Update UI with progress
    };
    ```
    """
    async def event_generator():
        while True:
            # Query execution status
            execution = db.query(Execution).join(Project).filter(
                Execution.id == execution_id,
                Project.user_id == current_user.id
            ).first()

            if not execution:
                yield f"data: {json.dumps({'error': 'Execution not found'})}\n\n"
                break

            # Calculate overall progress
            agent_statuses = execution.agent_execution_status or {}
            total_agents = len(execution.selected_agents) if execution.selected_agents else 0
            completed_agents = sum(
                1 for status in agent_statuses.values()
                if status.get('state') == 'completed'
            )
            overall_progress = (completed_agents / total_agents * 100) if total_agents > 0 else 0

            # Send current status
            data = {
                "execution_id": execution.id,
                "status": execution.status.value,
                "progress": int(overall_progress),
                "current_agent": execution.current_agent,
                "agent_statuses": agent_statuses,
                "message": f"Executing agents... {completed_agents}/{total_agents} completed"
            }

            yield f"data: {json.dumps(data)}\n\n"

            # If completed or failed, stop streaming
            if execution.status in [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED, ExecutionStatus.CANCELLED]:
                break

            # Wait before next update
            await asyncio.sleep(2)

    return StreamingResponse(
        event_generator(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no"
        }
    )


@router.get("/execute/{execution_id}/result", response_model=ExecutionResultResponse)
async def get_execution_result(
    execution_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Get final execution result including SDS document information.

    This endpoint should be called after execution completes.
    """
    execution = db.query(Execution).join(Project).filter(
        Execution.id == execution_id,
        Project.user_id == current_user.id
    ).first()

    if not execution:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Execution not found"
        )

    if execution.status != ExecutionStatus.COMPLETED:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Execution not yet completed. Current status: {execution.status.value}"
        )

    return ExecutionResultResponse(
        execution_id=execution.id,
        status=execution.status,
        sds_document_url=f"/api/pm-orchestrator/execute/{execution.id}/download" if execution.sds_document_path else None,
        execution_time=execution.duration_seconds,
        agents_used=len(execution.selected_agents) if execution.selected_agents else 0,
        total_cost=execution.total_cost,
        completed_at=execution.completed_at
    )


@router.get("/execute/{execution_id}/download")
async def download_sds_document(
    execution_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_user_from_token)
):
    """
    Download the generated SDS document.
    """
    execution = db.query(Execution).join(Project).filter(
        Execution.id == execution_id,
        Project.user_id == current_user.id
    ).first()

    if not execution:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Execution not found"
        )

    if not execution.sds_document_path:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="SDS document not available"
        )

    # Get project name for filename
    project = db.query(Project).filter(Project.id == execution.project_id).first()
    filename = f"SDS_{project.name.replace(' ', '_')}_{execution.id}.docx"

    return FileResponse(
        path=execution.sds_document_path,
        filename=filename,
        media_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    )


@router.get("/executions", response_model=List[ExecutionSchema])
async def list_executions(
    project_id: int = None,
    skip: int = 0,
    limit: int = 50,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Get execution history for the current user.

    Optional filters:
    - project_id: Filter by specific project
    - skip/limit: Pagination
    """
    query = db.query(Execution).filter(Execution.user_id == current_user.id)

    if project_id:
        # Verify project belongs to user
        project = db.query(Project).filter(
            Project.id == project_id,
            Project.user_id == current_user.id
        ).first()
        if not project:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Project not found"
            )
        query = query.filter(Execution.project_id == project_id)

    executions = query.order_by(Execution.created_at.desc()).offset(skip).limit(limit).all()

    return executions


# ==================== AGENTS LIST ENDPOINT ====================

@router.get("/agents")
async def list_available_agents(
    current_user: User = Depends(get_current_user)
):
    """
    Get list of all available Salesforce agents with their metadata.

    Returns:
    - id: Agent unique identifier
    - name: Agent display name (e.g., "Olivia (Business Analyst)")
    - description: What the agent does
    - required: Whether the agent is mandatory
    - available: Whether the agent file exists on the server
    - order: Execution order
    - avatar: Path to agent avatar image
    - estimatedTime: Estimated execution time in minutes
    """
    from app.services.agent_integration import AgentIntegrationService
    
    agent_service = AgentIntegrationService()
    agents = agent_service.get_available_agents()
    
    return {"agents": agents}
