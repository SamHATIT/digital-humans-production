"""
Professional Document Generator for SDS Documents
Generates high-quality Word documents with:
- Formatted tables with colored headers
- ERD diagrams as images (via mermaid)
- Properly formatted code blocks
- Professional styling

FIXED VERSION: Properly extracts data from database
"""

import os
import re
import json
import logging
import subprocess
import tempfile
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime

from docx import Document
from docx.shared import Inches, Pt, RGBColor, Cm
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.enum.table import WD_TABLE_ALIGNMENT
from docx.enum.style import WD_STYLE_TYPE
from docx.oxml.ns import qn, nsdecls
from docx.oxml import parse_xml
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker
from app.config import settings

logger = logging.getLogger(__name__)

# Color constants
HEADER_BLUE = RGBColor(31, 78, 121)  # #1F4E79
HEADER_LIGHT_BLUE = RGBColor(68, 114, 196)  # #4472C4
LINK_BLUE = RGBColor(37, 99, 235)  # #2563EB
GRAY_TEXT = RGBColor(107, 114, 128)

# Database connection
DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://digital_humans:DH_SecurePass2025!@127.0.0.1:5432/digital_humans_db")


class ProfessionalDocumentGenerator:
    """Generates professional-quality SDS documents"""
    
    def __init__(self):
        self.doc = None
        self.section_counter = {}
        
    def create_document(self) -> Document:
        """Initialize a new document with professional styles"""
        self.doc = Document()
        self._setup_styles()
        return self.doc
    
    def _setup_styles(self):
        """Setup custom styles for professional formatting"""
        styles = self.doc.styles
        
        # Code style
        if 'Code' not in [s.name for s in styles]:
            code_style = styles.add_style('Code', WD_STYLE_TYPE.PARAGRAPH)
            code_style.font.name = 'Consolas'
            code_style.font.size = Pt(9)
            code_style.paragraph_format.space_before = Pt(6)
            code_style.paragraph_format.space_after = Pt(6)
            code_style.paragraph_format.left_indent = Cm(0.5)
    
    def add_title_page(self, project_name: str, product: str, org_type: str):
        """Add professional title page"""
        # Main title
        title = self.doc.add_heading("Solution Design Specification", 0)
        title.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        # Project name
        p = self.doc.add_paragraph()
        p.alignment = WD_ALIGN_PARAGRAPH.CENTER
        run = p.add_run(project_name)
        run.font.size = Pt(18)
        run.font.bold = True
        
        # Subtitle
        p = self.doc.add_paragraph()
        p.alignment = WD_ALIGN_PARAGRAPH.CENTER
        run = p.add_run("Generated by Digital Humans System")
        run.font.size = Pt(11)
        run.font.color.rgb = GRAY_TEXT
        
        # Date
        p = self.doc.add_paragraph()
        p.alignment = WD_ALIGN_PARAGRAPH.CENTER
        run = p.add_run(f"Date: {datetime.now().strftime('%B %d, %Y')}")
        run.font.size = Pt(11)
        
        # Product info
        p = self.doc.add_paragraph()
        p.alignment = WD_ALIGN_PARAGRAPH.CENTER
        run = p.add_run(f"{product} • {org_type}")
        run.font.size = Pt(12)
        run.font.color.rgb = LINK_BLUE
        
        self.doc.add_page_break()
    
    def add_table(self, headers: List[str], rows: List[List[str]], 
                  title: Optional[str] = None, first_col_bold: bool = True) -> None:
        """Add a professionally formatted table"""
        if title:
            p = self.doc.add_paragraph()
            run = p.add_run(title)
            run.font.bold = True
            run.font.size = Pt(11)
        
        if not rows:
            self.doc.add_paragraph("No data available.")
            return
        
        # Create table
        table = self.doc.add_table(rows=1, cols=len(headers))
        table.style = 'Table Grid'
        table.alignment = WD_TABLE_ALIGNMENT.LEFT
        
        # Header row with blue background
        header_cells = table.rows[0].cells
        for i, header in enumerate(headers):
            cell = header_cells[i]
            cell.text = header
            
            # Apply blue background
            shading = parse_xml(f'<w:shd {nsdecls("w")} w:fill="1F4E79"/>')
            cell._tc.get_or_add_tcPr().append(shading)
            
            # White text, bold
            for paragraph in cell.paragraphs:
                for run in paragraph.runs:
                    run.font.color.rgb = RGBColor(255, 255, 255)
                    run.font.bold = True
                    run.font.size = Pt(10)
        
        # Data rows
        for row_data in rows:
            row = table.add_row()
            for i, cell_text in enumerate(row_data):
                cell = row.cells[i]
                cell.text = str(cell_text) if cell_text else ""
                
                # Format cell
                for paragraph in cell.paragraphs:
                    for run in paragraph.runs:
                        run.font.size = Pt(10)
                        if i == 0 and first_col_bold:
                            run.font.bold = True
        
        # Add spacing after table
        self.doc.add_paragraph()
    
    def parse_markdown_table(self, markdown: str) -> Tuple[List[str], List[List[str]]]:
        """Parse a markdown table into headers and rows"""
        lines = [l.strip() for l in markdown.strip().split('\n') if l.strip()]
        
        if len(lines) < 2:
            return [], []
        
        header_line = lines[0]
        headers = [h.strip() for h in header_line.split('|') if h.strip()]
        
        rows = []
        for line in lines[2:]:
            if '|' in line and not re.match(r'^[\s\-|]+$', line):
                raw_cells = line.split('|')
                cells = [c.strip() for c in raw_cells[1:-1]] if raw_cells[0] == '' else [c.strip() for c in raw_cells]
                if cells:
                    rows.append(cells[:len(headers)])
        
        return headers, rows
    
    def add_code_block(self, code: str, language: str = "apex"):
        """Add a formatted code block"""
        for line in code.split('\n'):
            p = self.doc.add_paragraph()
            run = p.add_run(line)
            run.font.name = 'Consolas'
            run.font.size = Pt(9)
            p.paragraph_format.space_before = Pt(0)
            p.paragraph_format.space_after = Pt(0)
            p.paragraph_format.left_indent = Cm(0.5)
    
    def add_mermaid_diagram(self, mermaid_code: str, title: str = None) -> bool:
        """Convert Mermaid diagram to image and add to document"""
        try:
            with tempfile.NamedTemporaryFile(mode='w', suffix='.mmd', delete=False) as f:
                f.write(mermaid_code)
                mmd_file = f.name
            
            png_file = mmd_file.replace('.mmd', '.png')
            
            result = subprocess.run(
                ['mmdc', '-i', mmd_file, '-o', png_file, '-b', 'white', '-w', '800'],
                capture_output=True,
                timeout=30
            )
            
            if result.returncode == 0 and os.path.exists(png_file):
                if title:
                    self.doc.add_heading(title, 3)
                self.doc.add_picture(png_file, width=Inches(6))
                self.doc.add_paragraph()
                
                os.unlink(mmd_file)
                os.unlink(png_file)
                return True
                
        except (subprocess.TimeoutExpired, FileNotFoundError) as e:
            logger.warning(f"Mermaid CLI not available: {e}")
        except Exception as e:
            logger.error(f"Error generating mermaid diagram: {e}")
        
        # Fallback: Add as code block
        if title:
            self.doc.add_heading(title, 3)
        
        p = self.doc.add_paragraph()
        run = p.add_run("[Diagram - View in Mermaid Live Editor: https://mermaid.live]")
        run.font.italic = True
        run.font.size = Pt(9)
        run.font.color.rgb = GRAY_TEXT
        
        self.add_code_block(mermaid_code, "mermaid")
        return False
    
    def process_markdown_content(self, content: str, section_title: str = None):
        """Process markdown content and add to document with proper formatting"""
        if section_title:
            self.doc.add_heading(section_title, 1)
        
        if not content or content == "No content":
            self.doc.add_paragraph("Content pending generation.")
            return
        
        lines = content.split('\n')
        i = 0
        
        while i < len(lines):
            line = lines[i].strip()
            
            if not line:
                i += 1
                continue
            
            # Mermaid diagram
            if line.startswith('```mermaid'):
                mermaid_lines = []
                i += 1
                while i < len(lines) and not lines[i].strip().startswith('```'):
                    mermaid_lines.append(lines[i])
                    i += 1
                mermaid_code = '\n'.join(mermaid_lines)
                self.add_mermaid_diagram(mermaid_code)
                i += 1
                continue
            
            # Code block
            if line.startswith('```'):
                language = line[3:].strip() or 'code'
                code_lines = []
                i += 1
                while i < len(lines) and not lines[i].strip().startswith('```'):
                    code_lines.append(lines[i])
                    i += 1
                code = '\n'.join(code_lines)
                self.add_code_block(code, language)
                i += 1
                continue
            
            # Table
            if '|' in line and i + 1 < len(lines) and re.match(r'^[\s\-|:]+$', lines[i + 1].strip()):
                table_lines = [line]
                i += 1
                while i < len(lines) and '|' in lines[i]:
                    table_lines.append(lines[i])
                    i += 1
                
                markdown_table = '\n'.join(table_lines)
                headers, rows = self.parse_markdown_table(markdown_table)
                if headers and rows:
                    self.add_table(headers, rows)
                continue
            
            # Headings
            if line.startswith('### '):
                self.doc.add_heading(line[4:], 3)
            elif line.startswith('## '):
                self.doc.add_heading(line[3:], 2)
            elif line.startswith('# '):
                self.doc.add_heading(line[2:], 1)
            
            # List items
            elif line.startswith('- ') or line.startswith('* '):
                self.doc.add_paragraph(line[2:], style='List Bullet')
            elif re.match(r'^\d+\.\s', line):
                self.doc.add_paragraph(re.sub(r'^\d+\.\s', '', line), style='List Number')
            
            # Bold text
            elif '**' in line:
                p = self.doc.add_paragraph()
                parts = re.split(r'(\*\*[^*]+\*\*)', line)
                for part in parts:
                    if part.startswith('**') and part.endswith('**'):
                        run = p.add_run(part[2:-2])
                        run.font.bold = True
                    else:
                        p.add_run(part)
            
            # Regular paragraph
            else:
                self.doc.add_paragraph(line)
            
            i += 1
    
    def save(self, filepath: str):
        """Save the document"""
        os.makedirs(os.path.dirname(filepath), exist_ok=True)
        self.doc.save(filepath)
        logger.info(f"Document saved to: {filepath}")
        return filepath


def get_deliverables_from_db(execution_id: int) -> Dict[str, Any]:
    """
    Fetch all deliverables from database for an execution
    
    Returns dict with:
    - business_requirements: list of BRs
    - use_cases: list of UCs  
    - architect_outputs: dict with solution_design, gap_analysis, wbs
    """
    engine = create_engine(DATABASE_URL)
    
    result = {
        "business_requirements": [],
        "project_summary": "",
        "use_cases": [],
        "architect_solution": None,
        "architect_gap": None,
        "architect_wbs": None
    }
    
    with engine.connect() as conn:
        # Get agent_deliverables
        deliverables = conn.execute(text("""
            SELECT deliverable_type, content 
            FROM agent_deliverables 
            WHERE execution_id = :exec_id
        """), {"exec_id": execution_id}).fetchall()
        
        for dtype, content in deliverables:
            try:
                data = json.loads(content) if isinstance(content, str) else content
                
                if dtype == "pm_br_extraction":
                    content_data = data.get("content", {})
                    result["project_summary"] = content_data.get("project_summary", "")
                    result["business_requirements"] = content_data.get("business_requirements", [])
                    
                elif dtype == "architect_solution_design":
                    result["architect_solution"] = extract_json_content_robust(data)
                    
                elif dtype == "architect_gap_analysis":
                    result["architect_gap"] = extract_json_content_robust(data)
                    
                elif dtype == "architect_wbs":
                    result["architect_wbs"] = extract_json_content_robust(data)
                    
            except Exception as e:
                logger.error(f"Error parsing {dtype}: {e}")
        
        # Get use cases from deliverable_items
        use_cases = conn.execute(text("""
            SELECT item_id, content_parsed, content_raw, parse_success
            FROM deliverable_items 
            WHERE execution_id = :exec_id AND item_type = 'use_case'
            ORDER BY item_id
        """), {"exec_id": execution_id}).fetchall()
        
        for item_id, content_parsed, content_raw, parse_success in use_cases:
            try:
                if parse_success and content_parsed:
                    uc_data = content_parsed if isinstance(content_parsed, dict) else json.loads(content_parsed)
                elif content_raw:
                    uc_data = json.loads(content_raw) if isinstance(content_raw, str) else content_raw
                else:
                    uc_data = {"id": item_id, "title": "Untitled"}
                result["use_cases"].append(uc_data)
            except Exception as e:
                logger.warning(f"Error parsing UC {item_id}: {e}")
                result["use_cases"].append({"id": item_id, "title": "Parse error"})
    
    logger.info(f"Fetched from DB: {len(result['business_requirements'])} BRs, {len(result['use_cases'])} UCs")
    return result


def extract_json_content(data: Dict) -> Optional[Dict]:
    """Extract JSON content, handling ```json wrapper"""
    try:
        content = data.get("content", {})
        if isinstance(content, dict):
            raw = content.get("raw", "")
            if isinstance(raw, str):
                # Strip ```json wrapper
                raw = re.sub(r'^```json\s*', '', raw.strip())
                raw = re.sub(r'```\s*$', '', raw.strip())
                return json.loads(raw)
            return content
        return None
    except json.JSONDecodeError as e:
        logger.error(f"JSON parse error: {e}")
        return None
    except Exception as e:
        logger.error(f"Extract error: {e}")
        return None


def generate_professional_sds(
    project: Any,
    agent_outputs: Dict[str, Any],
    execution_id: int,
    output_dir: str = None
) -> str:
    """
    Generate a professional SDS document
    
    FIXED: Now properly fetches data from database
    """
    if output_dir is None:
        output_dir = str(settings.OUTPUT_DIR)
    generator = ProfessionalDocumentGenerator()
    generator.create_document()
    
    # Fetch real data from database
    db_data = get_deliverables_from_db(execution_id)
    
    # Title page
    generator.add_title_page(
        project_name=project.name,
        product=project.salesforce_product or "Salesforce",
        org_type=project.organization_type or "New Implementation"
    )
    
    # ===================
    # EXECUTIVE SUMMARY
    # ===================
    generator.doc.add_heading("Executive Summary", 1)
    
    summary = db_data.get("project_summary", "")
    if not summary:
        summary = f"This Solution Design Specification outlines the technical implementation for {project.name}."
    
    generator.doc.add_paragraph(summary)
    
    stats = f"""
This document includes:
• {len(db_data['business_requirements'])} Business Requirements
• {len(db_data['use_cases'])} Use Cases
• Solution Architecture with Data Model
• Gap Analysis and Work Breakdown Structure
"""
    generator.doc.add_paragraph(stats)
    
    # ===================
    # BUSINESS REQUIREMENTS
    # ===================
    generator.doc.add_page_break()
    generator.doc.add_heading("Business Requirements", 1)
    
    brs = db_data.get("business_requirements", [])
    if brs:
        headers = ["ID", "Title", "Category", "Priority"]
        rows = []
        for br in brs:
            rows.append([
                br.get("id", ""),
                br.get("title", ""),
                br.get("category", ""),
                br.get("priority", "")
            ])
        generator.add_table(headers, rows)
        
        # Details
        generator.doc.add_heading("Requirement Details", 2)
        for br in brs[:20]:  # Limit to first 20 for brevity
            p = generator.doc.add_paragraph()
            run = p.add_run(f"{br.get('id', '')}: {br.get('title', '')}")
            run.font.bold = True
            generator.doc.add_paragraph(br.get("description", "No description"))
    else:
        generator.doc.add_paragraph("No business requirements extracted.")
    
    # ===================
    # USE CASES
    # ===================
    generator.doc.add_page_break()
    generator.doc.add_heading("Use Cases", 1)
    
    ucs = db_data.get("use_cases", [])
    if ucs:
        generator.doc.add_paragraph(f"Total: {len(ucs)} use cases generated.")
        
        # Summary table
        headers = ["ID", "Title", "Actor"]
        rows = []
        for uc in ucs[:50]:  # First 50 in summary
            rows.append([
                uc.get("id", ""),
                uc.get("title", "")[:60] + ("..." if len(uc.get("title", "")) > 60 else ""),
                uc.get("actor", "")
            ])
        generator.add_table(headers, rows)
        
        # Detailed UCs (first 20)
        generator.doc.add_page_break()
        generator.doc.add_heading("Use Case Details", 2)
        
        for uc in ucs[:20]:
            generator.doc.add_heading(f"{uc.get('id', '')}: {uc.get('title', '')}", 3)
            
            # Actor
            p = generator.doc.add_paragraph()
            run = p.add_run("Actor: ")
            run.font.bold = True
            p.add_run(uc.get("actor", "N/A"))
            
            # Preconditions
            preconds = uc.get("preconditions", [])
            if preconds:
                p = generator.doc.add_paragraph()
                run = p.add_run("Preconditions:")
                run.font.bold = True
                for pc in preconds[:5]:
                    generator.doc.add_paragraph(pc, style='List Bullet')
            
            # Main Flow
            main_flow = uc.get("main_flow", [])
            if main_flow:
                p = generator.doc.add_paragraph()
                run = p.add_run("Main Flow:")
                run.font.bold = True
                for i, step in enumerate(main_flow[:8], 1):
                    step_text = step.get("action", step) if isinstance(step, dict) else step
                    generator.doc.add_paragraph(f"{i}. {step_text}")
            
            # Postconditions
            postconds = uc.get("postconditions", [])
            if postconds:
                p = generator.doc.add_paragraph()
                run = p.add_run("Postconditions:")
                run.font.bold = True
                for pc in postconds[:3]:
                    generator.doc.add_paragraph(pc, style='List Bullet')
            
            generator.doc.add_paragraph()  # Spacing
    else:
        generator.doc.add_paragraph("No use cases generated.")
    
    # ===================
    # SOLUTION ARCHITECTURE
    # ===================
    generator.doc.add_page_break()
    generator.doc.add_heading("Solution Architecture", 1)
    
    arch_data = db_data.get("architect_solution")
    if arch_data:
        # Data Model
        data_model = arch_data.get("data_model", {})
        
        # Standard Objects
        std_objects = data_model.get("standard_objects", [])
        if std_objects:
            generator.doc.add_heading("Standard Objects", 2)
            for obj in std_objects:
                generator.doc.add_heading(obj.get("label", obj.get("api_name", obj.get("object", obj.get("name", "Unknown")))), 3)
                generator.doc.add_paragraph(f"Purpose: {obj.get('purpose', 'N/A')}")
                
                custom_fields = obj.get("custom_fields", obj.get("customizations", []))
                if custom_fields:
                    headers = ["Field"]
                    rows = []
                    for f in custom_fields[:15]:
                        if isinstance(f, dict):
                            rows.append([f"{f.get('api_name', '')} ({f.get('type', '')})"])
                        elif isinstance(f, str):
                            rows.append([f[:80]])
                    if rows:
                        generator.add_table(headers, rows)
        
        # Custom Objects
        custom_objects = data_model.get("custom_objects", [])
        if custom_objects:
            generator.doc.add_heading("Custom Objects", 2)
            for obj in custom_objects:
                generator.doc.add_heading(obj.get("label", obj.get("api_name", "Unknown")), 3)
                generator.doc.add_paragraph(f"API Name: {obj.get('api_name', 'N/A')}")
                generator.doc.add_paragraph(f"Purpose: {obj.get('purpose', 'N/A')}")
                
                fields = obj.get("fields", [])
                if fields:
                    headers = ["Field Definition"]
                    rows = []
                    for f in fields[:20]:
                        if isinstance(f, dict):
                            req = "Required" if f.get("required") else ""
                            rows.append([f"{f.get('api_name', '')} ({f.get('type', '')}) {req}".strip()])
                        elif isinstance(f, str):
                            rows.append([f[:100]])
                    if rows:
                        generator.add_table(headers, rows)
        
        # ERD Diagram
        erd = data_model.get("erd_mermaid", "")
        if erd:
            generator.doc.add_page_break()
            generator.doc.add_heading("Entity Relationship Diagram", 2)
            generator.add_mermaid_diagram(erd, None)
        
        # Security Model
        security = arch_data.get("security_model", {})
        if security:
            generator.doc.add_page_break()
            generator.doc.add_heading("Security Model", 2)
            
            profiles = security.get("profiles", [])
            if profiles:
                generator.doc.add_heading("Profiles", 3)
                for profile in profiles:
                    p = generator.doc.add_paragraph()
                    run = p.add_run(profile.get("name", "Unknown"))
                    run.font.bold = True
                    generator.doc.add_paragraph(profile.get("description", ""))
            
            perm_sets = security.get("permission_sets", [])
            if perm_sets:
                generator.doc.add_heading("Permission Sets", 3)
                headers = ["Name", "Description"]
                rows = [[ps.get("name", ""), ps.get("description", "")[:80]] for ps in perm_sets if isinstance(ps, dict)]
                generator.add_table(headers, rows)
        
        # Automation
        automation = arch_data.get("automation_design", {})
        flows = automation.get("flows", [])
        if flows:
            generator.doc.add_page_break()
            generator.doc.add_heading("Automation Design - Flows", 2)
            headers = ["Name", "Type", "Trigger", "Purpose"]
            rows = []
            for flow in flows[:15]:
                rows.append([
                    flow.get("name", ""),
                    flow.get("type", ""),
                    flow.get("trigger", "")[:40],
                    flow.get("purpose", "")[:50]
                ])
            generator.add_table(headers, rows)
    else:
        generator.doc.add_paragraph("Architecture design pending.")
    
    # ===================
    # GAP ANALYSIS
    # ===================
    gap_data = db_data.get("architect_gap")
    if gap_data:
        generator.doc.add_page_break()
        generator.doc.add_heading("Gap Analysis", 1)
        
        gaps = gap_data.get("gaps", [])
        if gaps:
            headers = ["ID", "Category", "Gap Description", "Complexity", "Effort (days)"]
            rows = []
            for gap in gaps[:20]:
                rows.append([
                    gap.get("id", ""),
                    gap.get("category", ""),
                    gap.get("gap_description", "")[:60],
                    gap.get("complexity", ""),
                    str(gap.get("effort_days", ""))
                ])
            generator.add_table(headers, rows)
    
    # ===================
    # WORK BREAKDOWN STRUCTURE
    # ===================
    wbs_data = db_data.get("architect_wbs")
    if wbs_data:
        generator.doc.add_page_break()
        generator.doc.add_heading("Work Breakdown Structure", 1)
        
        phases = wbs_data.get("phases", [])
        for phase in phases:
            generator.doc.add_heading(f"{phase.get('id', '')}: {phase.get('name', '')}", 2)
            generator.doc.add_paragraph(f"Duration: {phase.get('duration_weeks', 'TBD')} weeks")
            
            tasks = phase.get("tasks", [])
            if tasks:
                headers = ["Task ID", "Name", "Assigned To", "Effort (days)"]
                rows = []
                for task in tasks[:10]:
                    rows.append([
                        task.get("id", ""),
                        task.get("name", "")[:50],
                        task.get("assigned_agent", ""),
                        str(task.get("effort_days", ""))
                    ])
                generator.add_table(headers, rows)
    
    # ===================
    # SAVE
    # ===================
    safe_name = "".join(c for c in project.name if c.isalnum() or c in (' ', '-', '_')).rstrip()
    safe_name = safe_name.replace(' ', '_')
    filepath = f"{output_dir}/SDS_{safe_name}_{execution_id}.docx"
    
    return generator.save(filepath)


async def mermaid_to_image_kroki(mermaid_code: str) -> Optional[bytes]:
    """Convert Mermaid diagram to PNG using Kroki API"""
    import httpx
    import base64
    import zlib
    
    try:
        encoded = base64.urlsafe_b64encode(
            zlib.compress(mermaid_code.encode('utf-8'), 9)
        ).decode('ascii')
        
        url = f"https://kroki.io/mermaid/png/{encoded}"
        
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.get(url)
            if response.status_code == 200:
                return response.content
    except Exception as e:
        logger.error(f"Kroki API error: {e}")
    
    return None


def extract_json_content_robust(data: Dict) -> Optional[Dict]:
    """Extract JSON content - handles both raw JSON strings and structured dicts"""
    try:
        from json_repair import repair_json
        has_repair = True
    except ImportError:
        logger.warning("json-repair not installed")
        has_repair = False
    
    try:
        content = data.get("content", {})
        
        if isinstance(content, dict):
            # Case 1: Content has a "raw" field with JSON string
            raw = content.get("raw", "")
            if isinstance(raw, str) and raw.strip():
                # Strip ```json wrapper
                raw = re.sub(r'^```json\s*', '', raw.strip())
                raw = re.sub(r'```\s*$', '', raw.strip())
                
                try:
                    return json.loads(raw)
                except json.JSONDecodeError:
                    if has_repair:
                        repaired = repair_json(raw, return_objects=True)
                        if isinstance(repaired, dict):
                            logger.info(f"Successfully repaired truncated JSON ({len(raw)} chars)")
                            return repaired
                    return None
            
            # Case 2: Content is already a structured dict (no raw field or empty raw)
            # This is the case for architect outputs
            if "artifact_id" in content or "title" in content or "data_model" in content:
                return content
            
            # Case 3: Empty or unknown structure
            if content:
                return content
                
        return None
    except Exception as e:
        logger.error(f"JSON extraction error: {e}")
        return None
