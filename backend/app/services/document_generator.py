"""
Professional Document Generator for SDS Documents
Generates high-quality Word documents with:
- Formatted tables with colored headers
- ERD diagrams as images (via mermaid)
- Properly formatted code blocks
- Professional styling
"""

import os
import re
import json
import logging
import subprocess
import tempfile
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime

from docx import Document
from docx.shared import Inches, Pt, RGBColor, Cm
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.enum.table import WD_TABLE_ALIGNMENT
from docx.enum.style import WD_STYLE_TYPE
from docx.oxml.ns import qn, nsdecls
from docx.oxml import parse_xml

logger = logging.getLogger(__name__)

# Color constants (matching reference document)
HEADER_BLUE = RGBColor(31, 78, 121)  # #1F4E79
HEADER_LIGHT_BLUE = RGBColor(68, 114, 196)  # #4472C4
LINK_BLUE = RGBColor(37, 99, 235)  # #2563EB
GRAY_TEXT = RGBColor(107, 114, 128)


class ProfessionalDocumentGenerator:
    """Generates professional-quality SDS documents"""
    
    def __init__(self):
        self.doc = None
        self.section_counter = {}
        
    def create_document(self) -> Document:
        """Initialize a new document with professional styles"""
        self.doc = Document()
        self._setup_styles()
        return self.doc
    
    def _setup_styles(self):
        """Setup custom styles for professional formatting"""
        styles = self.doc.styles
        
        # Code style
        if 'Code' not in [s.name for s in styles]:
            code_style = styles.add_style('Code', WD_STYLE_TYPE.PARAGRAPH)
            code_style.font.name = 'Consolas'
            code_style.font.size = Pt(9)
            code_style.paragraph_format.space_before = Pt(6)
            code_style.paragraph_format.space_after = Pt(6)
            code_style.paragraph_format.left_indent = Cm(0.5)
    
    def add_title_page(self, project_name: str, product: str, org_type: str):
        """Add professional title page"""
        # Main title
        title = self.doc.add_heading("Solution Design Specification", 0)
        title.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        # Project name
        p = self.doc.add_paragraph()
        p.alignment = WD_ALIGN_PARAGRAPH.CENTER
        run = p.add_run(project_name)
        run.font.size = Pt(18)
        run.font.bold = True
        
        # Subtitle
        p = self.doc.add_paragraph()
        p.alignment = WD_ALIGN_PARAGRAPH.CENTER
        run = p.add_run("Generated by Digital Humans System")
        run.font.size = Pt(11)
        run.font.color.rgb = GRAY_TEXT
        
        # Date
        p = self.doc.add_paragraph()
        p.alignment = WD_ALIGN_PARAGRAPH.CENTER
        run = p.add_run(f"Date: {datetime.now().strftime('%B %d, %Y')}")
        run.font.size = Pt(11)
        
        # Product info
        p = self.doc.add_paragraph()
        p.alignment = WD_ALIGN_PARAGRAPH.CENTER
        run = p.add_run(f"{product} • {org_type}")
        run.font.size = Pt(12)
        run.font.color.rgb = LINK_BLUE
        
        self.doc.add_page_break()
    
    def add_table(self, headers: List[str], rows: List[List[str]], 
                  title: Optional[str] = None, first_col_bold: bool = True) -> None:
        """
        Add a professionally formatted table
        
        Args:
            headers: Column headers
            rows: Table data rows
            title: Optional table title
            first_col_bold: Whether to bold the first column
        """
        if title:
            p = self.doc.add_paragraph()
            run = p.add_run(title)
            run.font.bold = True
            run.font.size = Pt(11)
        
        # Create table
        table = self.doc.add_table(rows=1, cols=len(headers))
        table.style = 'Table Grid'
        table.alignment = WD_TABLE_ALIGNMENT.LEFT
        
        # Header row with blue background
        header_cells = table.rows[0].cells
        for i, header in enumerate(headers):
            cell = header_cells[i]
            cell.text = header
            
            # Apply blue background
            shading = parse_xml(f'<w:shd {nsdecls("w")} w:fill="1F4E79"/>')
            cell._tc.get_or_add_tcPr().append(shading)
            
            # White text, bold
            for paragraph in cell.paragraphs:
                for run in paragraph.runs:
                    run.font.color.rgb = RGBColor(255, 255, 255)
                    run.font.bold = True
                    run.font.size = Pt(10)
        
        # Data rows
        for row_data in rows:
            row = table.add_row()
            for i, cell_text in enumerate(row_data):
                cell = row.cells[i]
                cell.text = str(cell_text) if cell_text else ""
                
                # Format cell
                for paragraph in cell.paragraphs:
                    for run in paragraph.runs:
                        run.font.size = Pt(10)
                        if i == 0 and first_col_bold:
                            run.font.bold = True
        
        # Add spacing after table
        self.doc.add_paragraph()
    
    def parse_markdown_table(self, markdown: str) -> Tuple[List[str], List[List[str]]]:
        """
        Parse a markdown table into headers and rows
        
        Args:
            markdown: Markdown table string
            
        Returns:
            Tuple of (headers, rows)
        """
        lines = [l.strip() for l in markdown.strip().split('\n') if l.strip()]
        
        if len(lines) < 2:
            return [], []
        
        # Parse header
        header_line = lines[0]
        headers = [h.strip() for h in header_line.split('|') if h.strip()]
        
        # Skip separator line (line with dashes)
        rows = []
        for line in lines[2:]:  # Skip header and separator
            if '|' in line and not re.match(r'^[\s\-|]+$', line):
                cells = [c.strip() for c in line.split('|') if c.strip() or line.count('|') > len(headers)]
                # Handle empty cells
                raw_cells = line.split('|')
                cells = [c.strip() for c in raw_cells[1:-1]] if raw_cells[0] == '' else [c.strip() for c in raw_cells]
                if cells:
                    rows.append(cells[:len(headers)])  # Ensure same number of columns
        
        return headers, rows
    
    def add_code_block(self, code: str, language: str = "apex"):
        """Add a formatted code block"""
        # Add light gray background box effect via paragraph
        for line in code.split('\n'):
            p = self.doc.add_paragraph()
            run = p.add_run(line)
            run.font.name = 'Consolas'
            run.font.size = Pt(9)
            p.paragraph_format.space_before = Pt(0)
            p.paragraph_format.space_after = Pt(0)
            p.paragraph_format.left_indent = Cm(0.5)
    
    def add_mermaid_diagram(self, mermaid_code: str, title: str = None) -> bool:
        """
        Convert Mermaid diagram to image and add to document
        
        Args:
            mermaid_code: Mermaid diagram code
            title: Optional diagram title
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Try using mermaid-cli if available
            with tempfile.NamedTemporaryFile(mode='w', suffix='.mmd', delete=False) as f:
                f.write(mermaid_code)
                mmd_file = f.name
            
            png_file = mmd_file.replace('.mmd', '.png')
            
            # Try mmdc (mermaid-cli)
            result = subprocess.run(
                ['mmdc', '-i', mmd_file, '-o', png_file, '-b', 'white', '-w', '800'],
                capture_output=True,
                timeout=30
            )
            
            if result.returncode == 0 and os.path.exists(png_file):
                if title:
                    self.doc.add_heading(title, 3)
                self.doc.add_picture(png_file, width=Inches(6))
                self.doc.add_paragraph()  # Spacing
                
                # Cleanup
                os.unlink(mmd_file)
                os.unlink(png_file)
                return True
                
        except (subprocess.TimeoutExpired, FileNotFoundError) as e:
            logger.warning(f"Mermaid CLI not available or failed: {e}")
        except Exception as e:
            logger.error(f"Error generating mermaid diagram: {e}")
        
        # Fallback: Add as formatted code block with note
        if title:
            self.doc.add_heading(title, 3)
        
        p = self.doc.add_paragraph()
        run = p.add_run("[Diagram - View in Mermaid Live Editor: https://mermaid.live]")
        run.font.italic = True
        run.font.size = Pt(9)
        run.font.color.rgb = GRAY_TEXT
        
        self.add_code_block(mermaid_code, "mermaid")
        return False
    
    def add_adr_table(self, adr_data: Dict[str, str]):
        """Add an Architecture Decision Record as a formatted table"""
        rows = []
        for key in ['Décision', 'Decision', 'Contexte', 'Context', 
                    'Options évaluées', 'Options', 'Justification', 
                    'Conséquences', 'Consequences']:
            if key in adr_data:
                rows.append([key, adr_data[key]])
        
        if rows:
            self.add_table(['Aspect', 'Description'], rows, first_col_bold=True)
    
    def process_markdown_content(self, content: str, section_title: str = None):
        """
        Process markdown content and add to document with proper formatting
        
        Handles:
        - Headings (# ## ###)
        - Tables
        - Code blocks
        - Mermaid diagrams
        - Lists
        - Regular paragraphs
        """
        if section_title:
            self.doc.add_heading(section_title, 1)
        
        # Split content into blocks
        lines = content.split('\n')
        i = 0
        
        while i < len(lines):
            line = lines[i].strip()
            
            # Skip empty lines
            if not line:
                i += 1
                continue
            
            # Mermaid diagram
            if line.startswith('```mermaid'):
                mermaid_lines = []
                i += 1
                while i < len(lines) and not lines[i].strip().startswith('```'):
                    mermaid_lines.append(lines[i])
                    i += 1
                mermaid_code = '\n'.join(mermaid_lines)
                self.add_mermaid_diagram(mermaid_code)
                i += 1
                continue
            
            # Code block
            if line.startswith('```'):
                language = line[3:].strip() or 'code'
                code_lines = []
                i += 1
                while i < len(lines) and not lines[i].strip().startswith('```'):
                    code_lines.append(lines[i])
                    i += 1
                code = '\n'.join(code_lines)
                self.add_code_block(code, language)
                i += 1
                continue
            
            # Table detection
            if '|' in line and i + 1 < len(lines) and re.match(r'^[\s\-|:]+$', lines[i + 1].strip()):
                # Collect table lines
                table_lines = [line]
                i += 1
                while i < len(lines) and '|' in lines[i]:
                    table_lines.append(lines[i])
                    i += 1
                
                # Parse and add table
                markdown_table = '\n'.join(table_lines)
                headers, rows = self.parse_markdown_table(markdown_table)
                if headers and rows:
                    self.add_table(headers, rows)
                continue
            
            # Headings
            if line.startswith('### '):
                self.doc.add_heading(line[4:], 3)
            elif line.startswith('## '):
                self.doc.add_heading(line[3:], 2)
            elif line.startswith('# '):
                self.doc.add_heading(line[2:], 1)
            
            # List items
            elif line.startswith('- ') or line.startswith('* '):
                self.doc.add_paragraph(line[2:], style='List Bullet')
            elif re.match(r'^\d+\.\s', line):
                self.doc.add_paragraph(re.sub(r'^\d+\.\s', '', line), style='List Number')
            
            # Bold text handling
            elif '**' in line:
                p = self.doc.add_paragraph()
                parts = re.split(r'(\*\*[^*]+\*\*)', line)
                for part in parts:
                    if part.startswith('**') and part.endswith('**'):
                        run = p.add_run(part[2:-2])
                        run.font.bold = True
                    else:
                        p.add_run(part)
            
            # Regular paragraph
            else:
                self.doc.add_paragraph(line)
            
            i += 1
    
    def save(self, filepath: str):
        """Save the document"""
        os.makedirs(os.path.dirname(filepath), exist_ok=True)
        self.doc.save(filepath)
        logger.info(f"Document saved to: {filepath}")
        return filepath


def generate_professional_sds(
    project: Any,
    agent_outputs: Dict[str, Any],
    execution_id: int,
    output_dir: str = "/app/outputs"
) -> str:
    """
    Generate a professional SDS document
    
    Args:
        project: Project model instance
        agent_outputs: Dictionary of agent outputs
        execution_id: Execution ID
        output_dir: Output directory path
        
    Returns:
        Path to generated document
    """
    generator = ProfessionalDocumentGenerator()
    generator.create_document()
    
    # Title page
    generator.add_title_page(
        project_name=project.name,
        product=project.salesforce_product,
        org_type=project.organization_type
    )
    
    # Executive Summary
    generator.doc.add_heading("Executive Summary", 1)
    summary = f"""This Solution Design Specification outlines the technical implementation for {project.name}, a {project.salesforce_product} solution.

The Digital Humans AI system has orchestrated {len(agent_outputs)} specialized AI agents to produce comprehensive technical specifications covering business analysis, solution architecture, development specifications, and deployment strategy."""
    generator.doc.add_paragraph(summary)
    
    # Business Requirements
    generator.doc.add_heading("Business Requirements", 1)
    requirements = project.business_requirements or "No requirements specified"
    for line in requirements.strip().split('\n')[:7]:
        if line.strip():
            generator.doc.add_paragraph(line.strip(), style='List Bullet')
    
    # Agent outputs
    agent_names = {
        'ba': 'Business Analysis',
        'architect': 'Solution Architecture', 
        'apex': 'Apex Development Specifications',
        'lwc': 'Lightning Web Components',
        'admin': 'Configuration & Administration',
        'qa': 'Quality Assurance & Testing',
        'devops': 'DevOps & Deployment',
        'data': 'Data Migration',
        'trainer': 'Training & Documentation',
        'pm': 'Project Management Summary'
    }
    
    for agent_id, result in agent_outputs.items():
        generator.doc.add_page_break()
        section_name = agent_names.get(agent_id, agent_id.upper())
        
        # Extract content
        output = result.get("output", result) if isinstance(result, dict) else result
        json_data = output.get("json_data", output) if isinstance(output, dict) else output
        
        content = "No content generated"
        if isinstance(json_data, dict):
            content_obj = json_data.get("content", {})
            if isinstance(content_obj, dict):
                content = content_obj.get("raw_markdown", content_obj.get("content", "No content"))
            elif isinstance(content_obj, str):
                content = content_obj
        
        generator.process_markdown_content(content, section_title=section_name)
    
    # Save document
    safe_name = "".join(c for c in project.name if c.isalnum() or c in (' ', '-', '_')).rstrip()
    safe_name = safe_name.replace(' ', '_')
    filepath = f"{output_dir}/SDS_{execution_id}_{safe_name}.docx"
    
    return generator.save(filepath)


async def mermaid_to_image_kroki(mermaid_code: str) -> Optional[bytes]:
    """
    Convert Mermaid diagram to PNG using Kroki API
    
    Args:
        mermaid_code: Mermaid diagram code
        
    Returns:
        PNG image bytes or None if failed
    """
    import httpx
    import base64
    import zlib
    
    try:
        # Encode for Kroki
        encoded = base64.urlsafe_b64encode(
            zlib.compress(mermaid_code.encode('utf-8'), 9)
        ).decode('ascii')
        
        url = f"https://kroki.io/mermaid/png/{encoded}"
        
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.get(url)
            if response.status_code == 200:
                return response.content
    except Exception as e:
        logger.error(f"Kroki API error: {e}")
    
    return None
