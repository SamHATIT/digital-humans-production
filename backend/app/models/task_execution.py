"""
TaskExecution Model - ORCH-03a
Tracks the execution state of each WBS task during incremental build phase
"""
from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Enum, JSON
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from app.database import Base
import enum


class TaskStatus(str, enum.Enum):
    """Status of a WBS task execution"""
    PENDING = "pending"           # Not started yet
    RUNNING = "running"           # Agent is generating code/config
    DEPLOYING = "deploying"       # SFDX deploying to sandbox
    TESTING = "testing"           # Elena running tests
    PASSED = "passed"             # Tests passed, ready for commit
    COMMITTING = "committing"     # Git commit/PR in progress
    COMPLETED = "completed"       # Fully done (merged or ready)
    FAILED = "failed"             # Failed after max retries
    SKIPPED = "skipped"           # Skipped (dependency failed or manual skip)
    BLOCKED = "blocked"           # Waiting for dependency


class TaskExecution(Base):
    """
    Tracks individual WBS task execution during build phase.
    One record per task per execution.
    """
    __tablename__ = "task_executions"
    
    id = Column(Integer, primary_key=True, index=True)
    execution_id = Column(Integer, ForeignKey("executions.id"), nullable=False, index=True)
    
    # Task identification (from WBS)
    task_id = Column(String(50), nullable=False, index=True)  # e.g., "TASK-001"
    task_name = Column(String(255), nullable=False)
    phase_name = Column(String(100))  # WBS phase name
    
    # Rich task context from WBS (BUG-044 fix)
    description = Column(Text)                    # Detailed task description
    validation_criteria = Column(JSON)            # ["DONE WHEN: ...", "VERIFIED BY: ..."]
    deliverables = Column(JSON)                   # ["Component A", "Document B", ...]
    gap_refs = Column(JSON)                       # ["GAP-001-01", "GAP-001-02", ...]
    effort_days = Column(Integer)                 # Estimated effort in days
    test_approach = Column(String(100))           # "Unit test", "Manual test", etc.
    
    # Assignment
    assigned_agent = Column(String(50))  # diego, zara, raj, etc.
    
    # Status tracking
    status = Column(Enum(TaskStatus), default=TaskStatus.PENDING, nullable=False)
    attempt_count = Column(Integer, default=0)  # Number of attempts (max 3)
    
    # Results
    generated_files = Column(JSON)        # List of files generated by agent
    deploy_result = Column(JSON)          # SFDX deploy result
    test_result = Column(JSON)            # Elena's test results
    git_commit_sha = Column(String(64))   # Git commit SHA if committed
    git_pr_url = Column(String(500))      # PR URL if created
    
    # Error tracking
    last_error = Column(Text)             # Last error message
    error_log = Column(JSON)              # Full error history [{attempt, error, timestamp}]
    
    # Dependencies
    depends_on = Column(JSON)             # List of task_ids this depends on
    
    # Timestamps
    started_at = Column(DateTime(timezone=True))
    completed_at = Column(DateTime(timezone=True))
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())
    
    # Relationships
    execution = relationship("Execution", back_populates="task_executions")
    
    def __repr__(self):
        return f"<TaskExecution {self.task_id} ({self.status.value})>"
    
    def can_start(self, completed_tasks: list) -> bool:
        """Check if all dependencies are completed"""
        if not self.depends_on:
            return True
        return all(dep in completed_tasks for dep in self.depends_on)
    
    def record_error(self, error: str):
        """Record an error and increment attempt count"""
        import datetime
        self.attempt_count += 1
        self.last_error = error
        if not self.error_log:
            self.error_log = []
        self.error_log.append({
            "attempt": self.attempt_count,
            "error": error,
            "timestamp": datetime.datetime.now().isoformat()
        })
    
    def has_retries_left(self, max_retries: int = 3) -> bool:
        """Check if task can be retried"""
        return self.attempt_count < max_retries
